using System.Collections.Generic;
using System.Linq;

namespace System.FunctionalExtensions
{
    public static class Option
    {
        /// <summary>
        /// Create a <c>Some</c> based on the given <paramref name="value"/>.
        /// </summary>
        public static Option<TValue> Some<TValue>(TValue value)
        {
            return new Option<TValue>(value);
        }

        /// <summary>
        /// Create a <c>None</c> for the given type <typeparamref name="TValue"/>.
        /// </summary>
        public static Option<TValue> None<TValue>()
        {
            return new Option<TValue>();
        }

        /// <summary>
        /// Return the value of a <c>Some</c> or throw an exception returned from the function <paramref name="efunc"/>.
        /// </summary>
        public static T Value<T>(this Option<T> option, Func<Exception> efunc)
        {
            if (option.IsNone)
            {
                throw efunc();
            }

            return option.Value;
        }

        /// <summary>
        /// Return the value of a <c>Some</c> or in the case of <c>None</c> a default value generated by the function <paramref name="default"/>.
        /// </summary>
        public static T Value<T>(this Option<T> a, Func<T> @default)
        {
            return a.IsSome ? a.Value : @default();
        }

        /// <summary>
        /// Create an <see cref="IEnumerable{T}"/> from an Option. A <c>None</c> yields an empty enumerable, a <c>Some</c> yields a enumeration
        /// with the single value.
        /// </summary>
        public static IEnumerable<T> ToEnumerable<T>(this Option<T> a)
        {
            if (a.IsSome) { yield return a.Value; }
        }

        /// <summary>
        /// Return the value of a <c>Some</c> or in the case of <c>None</c> <c>null</c>.
        /// </summary>
        public static T NullableValue<T>(this Option<T> a) where T : class
        {
            return a.IsNone ? null : a.Value;
        }

        /// <summary>
        /// Return the value of a <c>Some</c> or in the case of <c>None</c> the default value <paramref name="default"/>.
        /// </summary>
        public static T Value<T>(this Option<T> a, T @default)
        {
            return a.IsSome ? a.Value : @default;
        }

        /// <summary>
        /// Return the value of a <c>Some</c> or in the case of <c>None</c> the default value of the type <typeparamref name="T"/>.
        /// </summary>
        public static T ValueOrDefault<T>(this Option<T> a)
        {
            return a.Value(default(T));
        }

        /// <summary>
        /// Return the result of applying the value of a <c>Some</c> to the function <paramref name="fn"/> or in the case of
        /// a <c>None</c> the default value generated from the function <paramref name="default"/>.
        /// </summary>
        public static TResult SelectValue<T, TResult>(this Option<T> a, Func<T, TResult> fn, Func<TResult> @default)
        {
            return a.IsSome ? fn(a.Value) : @default();
        }

        /// <summary>
        /// Return the result of applying the value of a <c>Some</c> to the function <paramref name="fn"/> or in the case of
        /// a <c>None</c> the default value <paramref name="default"/>.
        /// </summary>
        public static TResult SelectValue<T, TResult>(this Option<T> a, Func<T, TResult> fn, TResult @default)
        {
            return a.IsSome ? fn(a.Value) : @default;
        }

        /// <summary>
        /// Convert <see cref="Option{T}"/> to an <see cref="Nullable{T}"/>.
        /// </summary>
        public static T? ToNullable<T>(this Option<T> a) where T : struct
        {
            if (a.IsSome)
            {
                return new Nullable<T>(a.Value);
            }
            return new Nullable<T>();
        }

        /// <summary>
        /// Convert a <see cref="Nullable{T}"/> value object to an option where null yields to <c>None</c> and any
        /// other value to <c>Some(value)</c>.
        /// </summary>
        public static Option<T> ToOption<T>(this Nullable<T> a) where T : struct
        {
            if (!a.HasValue)
            {
                return Option.None<T>();
            }
            return a.Value.ToOption();
        }

        /// <summary>
        /// Convert a reference object to an option where null yields to <c>None</c> and any
        /// other value to <c>Some(value)</c>.
        /// </summary>
        public static Option<T> ToOption<T>(this T a)
        {
            if (ReferenceEquals(null, a))
            {
                return Option.None<T>();
            }
            return Option.Some(a);
        }

        /// <summary>
        /// Convert an enumerable to an <see cref="Option{T}"/>. The result will be a <c>Some</c> with the first element of the
        /// enumerable or a <c>None</c> if the enumerable is empty.
        /// </summary>
        public static Option<T> ToOptionFromEnumerable<T>(this IEnumerable<T> xs)
        {
            foreach (var x in xs)
            {
                return x.ToOption();
            }

            return Option.None<T>();
        }

        /// <summary>
        /// Try to cast an object to an <see cref="Option{T}"/> some. If the cast fails, a <c>None</c> is yield.
        /// </summary>
        public static Option<T> Cast<T>(this object a)
        {
            try
            {
                var t = (T)a;
                return t.ToOption();
            }
            catch
            {
                return Option.None<T>();
            }
        }

        /// <summary>
        /// Execute the side effect <paramref name="action"/> with the value of the <c>Some</c> or do nothing.
        /// </summary>
        public static void Run<T>(this Option<T> a, Action<T> action)
        {
            if (a.IsSome)
            {
                action(a.Value);
            }
        }

        /// <summary>
        /// Excecute the side effect <paramref name="action"/> with the value of a <c>Some</c> or throw an
        /// exception (either <paramref name="e"/> or <see cref="InvalidOperationException"/>)
        /// </summary>
        public static void RunOrThrow<T>(this Option<T> a, Action<T> action, Exception e = null)
        {
            if (a.IsNone)
            {
                throw e ?? new InvalidOperationException("RunOrThrow: Option.None can not be run.");
            }

            action(a.Value);
        }

        /// <summary>
        /// Execute the side effect <paramref name="action"/> if the value in the <c>Some</c> of type <c>bool</c> is
        /// <c>true</c>. Otherwise nothing is done.
        /// </summary>
        public static void RunWhenTrue(this Option<bool> a, Action action)
        {
            if (a.IsSome && a.Value)
            {
                action();
            }
        }

        /// <summary>
        /// Reduce/Collapse a nested <see cref="Option{T}"/>.
        /// </summary>
        public static Option<T> Collapse<T>(this Option<Option<T>> t)
        {
            if (t.IsNone || t.Value.IsNone)
            {
                return Option.None<T>();
            }
            return t.Value;
        }

        /// <summary>
        /// Return <paramref name="a"/> if it is a <c>Some</c>, else return a <c>Some</c> with the value of <paramref name="b"/>.
        /// </summary>
        public static Option<T> Or<T>(this Option<T> a, T b)
        {
            return a.IsSome ? a : b.ToOption();
        }

        /// <summary>
        /// Return <paramref name="a"/> if it is a <c>Some</c>, else return a <c>Some</c> with the return value of the function <paramref name="b"/>.
        /// </summary>
        public static Option<T> Or<T>(this Option<T> a, Func<Option<T>> b)
        {
            return a.IsSome ? a : b();
        }

        /// <summary>
        /// Return <paramref name="a"/> if it is a <c>Some</c>, else return <paramref name="b"/>.
        /// </summary>
        public static Option<T> Or<T>(this Option<T> a, Option<T> b)
        {
            return a.IsSome ? a : b;
        }

        /// <summary>
        /// Return a new <c>Some</c> containing the transformed value of <paramref name="a"/>. If <paramref name="a"/> is a
        /// <c>None</c>, a <c>None</c> will be returned. The function <paramref name="func"/> will be used to transform a
        /// <c>Some</c>.
        /// </summary>
        public static Option<TResult> Select<T, TResult>(this Option<T> a, Func<T, TResult> func)
        {
            return a.IsSome ? new Option<TResult>(func(a.Value)) : Option.None<TResult>();
        }

        /// <summary>
        /// Apply the <paramref name="selector"/> to every option in the given enumerable <paramref name="options"/>.
        /// </summary>
        public static IEnumerable<Option<TResult>> Select<T, TResult>(this IEnumerable<Option<T>> options, Func<T, TResult> selector)
        {
            return options.Select(option => option.Select(selector));
        }

        /// <summary>
        /// Return an enumerable containing only the <c>Some</c>'s of the given <paramref name="options"/>.
        /// </summary>
        public static IEnumerable<T> SelectValid<T>(this IEnumerable<Option<T>> options)
        {
            return SelectValid(options, m => m);
        }

        /// <summary>
        /// Return an enumerable containing only the with the function <paramref name="func"/> transformed <c>Some</c>'s of the
        /// given <paramref name="options"/>.
        /// </summary>
        public static IEnumerable<TResult> SelectValid<T, TResult>(this IEnumerable<Option<T>> options, Func<T, TResult> func)
        {
            return from option in options
                   where option.IsSome
                   select func(option.Value);
        }

        /// <summary>
        /// Filter an enumerable <paramref name="xs"/> of values with the predicate function <paramref name="pred"/>.
        /// If <paramref name="pred"/> returns <c>None</c>, the result of <see cref="WhereOption{T}"/> will also be <c>None</c>.
        /// Else the boolean value inside the <c>Some</c> returned by the predicate function <paramref name="pred"/> will be used
        /// to filter the values in <paramref name="xs"/>. Only values for which the predicate returns <c>true</c> are then
        /// included in the resulting enumeration.
        /// </summary>
        public static Option<IEnumerable<T>> WhereOption<T>(this IEnumerable<T> xs, Func<T, Option<bool>> pred)
        {
            var l = new List<T>();
            foreach (var x in xs)
            {
                var r = pred(x);
                if (r.IsNone)
                {
                    return Option.None<IEnumerable<T>>();
                }
                if (r.Value)
                {
                    l.Add(x);
                }
            }
            return Option.Some<IEnumerable<T>>(l);
        }

        /// <summary>
        /// Filter a single <see cref="Option"/>. <see cref="Where"/> returns <c>None</c> if either <paramref name="a"/> is None or
        /// <paramref name="pred"/> return <c>false</c>. Otherwise <paramref name="a"/> is returned.
        /// </summary>
        public static Option<T> Where<T>(this Option<T> a, Func<T, bool> pred)
        {
            if (a.IsSome && pred(a.Value))
            {
                return a;
            }
            return Option.None<T>();
        }

        /// <summary>
        /// Project the value in the monadic option context (monadic bind operation).
        /// Note: Needed for LINQ syntax
        /// </summary>
        public static Option<TResult> SelectMany<T, TResult>(this Option<T> a, Func<T, Option<TResult>> selector)
        {
            return a.IsNone ? Option.None<TResult>() : selector(a.Value);
        }

        /// <summary>
        /// Special version of a monadic bind for performance reasons. It combines SelectMany (monadic bind) with ToOption (monadic unit),
        /// so that lambdas are not deeply nested.
        /// Note: Needed for LINQ syntax
        /// </summary>
        public static Option<TResult> SelectMany<T, TOption, TResult>(this Option<T> a, Func<T, Option<TOption>> optionSelector, Func<T, TOption, TResult> resultSelector)
        {
            return a.SelectMany(x => optionSelector(x).SelectMany(y => resultSelector(x, y).ToOption()));
        }

        /// <summary>
        /// Turn a enumeration of <c>Some</c>'s into a <c>Some</c> containing an enumeration of the <c>Some</c>'s values. If the
        /// enumeration <paramref name="options"/> contains a <c>None</c>, <see cref="Sequence{T}"/> will also
        /// return a <c>None</c>.
        /// </summary>
        public static Option<IEnumerable<T>> Sequence<T>(this IEnumerable<Option<T>> options)
        {
            var list = new List<T>();
            foreach(var option in options)
            {
                if (option.IsNone)
                {
                    return Option.None<IEnumerable<T>>();
                }
                list.Add(option.Value);
            }

            return Option.Some<IEnumerable<T>>(list);
        }
    }
}